
# design_patterns

**通过重构的方式，来迭代代码**

- 重构的技法
    1. 静态 -> 动态
    2. 早绑定 -> 晚绑定
    3. 继承 -> 组合
    4. 编译时依赖 -> 运行时依赖
    5. 紧耦合 -> 松耦合


- 目的： 复用性 and 拓展性

- 封装、隔离： 稳定与非稳定的隔离，提取稳定接口，隔离（封装）非稳定逻辑

- SOlID 原则
    1. 单一职责(S)：一个类仅负责一个功能
    2. 开闭原则(O): 实现新功能时能保持已有代码不变
    3. 里氏替换原则(L): 子类必须保持与父类行为的兼容。重写一个方法是对基类行为进行扩展， 而不是将其完全替换。（子类能替代父类的功能）
    4. 接口隔离原则(I): 接口功能要专一
    5. 依赖倒置原则(D): 高层次类不依赖于低层次类，接口不依赖于实现

    
## 行为模式

[【模板方法模式】](./src/Template%20Method.md) ： 抽象算法步骤

[【策略模式】](./src/Strategy.md) ：封装算法对象，随时替换

[【观察者模式】](./src/Observer.md) ：实现订阅发布架构

[【中介者模式】](./src/Meditor.md) : 解除任务发起者和执行者的耦合，中介者负责重定向任务需求

[【备忘录模式】](./src/Memento.md) :  缓存对象的快照，用于恢复对象到特定状态

[【状态模式】](./src/State.md) : 将任务流程抽象成具体的几个状态，由State对象完成任务处理并切换状态（优先状态机）

[【责任链模式】](./src/ChainOfResponsibility.md): 工作对象组成队列（链表），将任务依次传递，直到终止

[【命令模式】](./src/Command.md) : 任务抽象为对象，解除调用者和执行者的耦合，任务可排序和延迟执行

[【访问者模式】](./src/Visitor.md) : 不改变现有接口拓展对象功能，接收访问者，访问者使用当前对象`this.accept(visitor) {visitor.call(this)}`
## 结构型模式

[【装饰模式】](./src/Decorator.md) ： 运行时拓展现存接口的功能（嵌套拓展原有接口对应的功能）

[【桥接模式】](./src/Bridge.md) : 分离抽象工作和具体工作，组合实现具体工作的对象

[【适配器模式](./src/Adapter.md) : 旧有接口向新接口的迁移

[【门面模式】](./src/Facade.md) : 包装复杂的子系统，精简接口

[【代理模式】](./src/Proxy.md) : 代理前置和后置操作，实现功能对象的透明使用

[【桥接模式】](./src/Bridge.md) : 分离抽象层次的工作和底层具体工作，组合具体工作实现对象

[【装饰器模式】](./src/Decorator.md) : 嵌套拓展现有接口，装饰器需实现并组合接口引用

## 对象创建模式

[【工厂模式】](./src/Factory.md) : 根据不同的需求生成不同的具体对象（多态对象）

[【抽象工厂模式】](./src/Ab_Factory.md) :  一个具体工厂生成一系列相关的对象（配合工作）

[【原型模式】](./src/Prototype.md): 返回自我拷贝，无需知道具体类型

[【生成器模式】](./src/Builder.md): 复杂对象的构造过程提取到专用的对象中，根据不同需求完成具体步骤

【单例模式】：懒汉（数据竞争），饿汉

